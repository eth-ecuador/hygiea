{"version":3,"sources":["../../../../../front-doctor/node_modules/viem/errors/abi.ts","../../../../../front-doctor/node_modules/viem/utils/abi/formatAbiItem.ts","../../../../../front-doctor/node_modules/viem/utils/regex.ts","../../../../../front-doctor/node_modules/viem/utils/abi/encodeAbiParameters.ts","../../../../../front-doctor/node_modules/viem/utils/hash/hashSignature.ts","../../../../../front-doctor/node_modules/abitype/src/regex.ts","../../../../../front-doctor/node_modules/abitype/src/human-readable/formatAbiParameter.ts","../../../../../front-doctor/node_modules/abitype/src/human-readable/formatAbiParameters.ts","../../../../../front-doctor/node_modules/viem/utils/hash/normalizeSignature.ts","../../../../../front-doctor/node_modules/viem/utils/hash/toSignatureHash.ts","../../../../../front-doctor/node_modules/viem/utils/hash/toSignature.ts","../../../../../front-doctor/node_modules/abitype/src/human-readable/formatAbiItem.ts","../../../../../front-doctor/node_modules/viem/utils/hash/toFunctionSelector.ts","../../../../../front-doctor/node_modules/viem/constants/solidity.ts","../../../../../front-doctor/node_modules/viem/utils/encoding/fromBytes.ts","../../../../../front-doctor/node_modules/viem/utils/abi/formatAbiItemWithArgs.ts","../../../../../front-doctor/node_modules/viem/utils/abi/decodeAbiParameters.ts","../../../../../front-doctor/node_modules/viem/utils/abi/decodeErrorResult.ts"],"sourcesContent":["import type { Abi, AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport type AbiConstructorNotFoundErrorType = AbiConstructorNotFoundError & {\n  name: 'AbiConstructorNotFoundError'\n}\nexport class AbiConstructorNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiConstructorParamsNotFoundErrorType =\n  AbiConstructorParamsNotFoundError & {\n    name: 'AbiConstructorParamsNotFoundError'\n  }\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiConstructorParamsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeInvalidErrorType =\n  AbiDecodingDataSizeInvalidError & {\n    name: 'AbiDecodingDataSizeInvalidError'\n  }\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      {\n        metaMessages: [`Data: ${data} (${size} bytes)`],\n        name: 'AbiDecodingDataSizeInvalidError',\n      },\n    )\n  }\n}\n\nexport type AbiDecodingDataSizeTooSmallErrorType =\n  AbiDecodingDataSizeTooSmallError & {\n    name: 'AbiDecodingDataSizeTooSmallError'\n  }\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'AbiDecodingDataSizeTooSmallError',\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type AbiDecodingZeroDataErrorType = AbiDecodingZeroDataError & {\n  name: 'AbiDecodingZeroDataError'\n}\nexport class AbiDecodingZeroDataError extends BaseError {\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.', {\n      name: 'AbiDecodingZeroDataError',\n    })\n  }\n}\n\nexport type AbiEncodingArrayLengthMismatchErrorType =\n  AbiEncodingArrayLengthMismatchError & {\n    name: 'AbiEncodingArrayLengthMismatchError'\n  }\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingArrayLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingBytesSizeMismatchErrorType =\n  AbiEncodingBytesSizeMismatchError & {\n    name: 'AbiEncodingBytesSizeMismatchError'\n  }\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n      { name: 'AbiEncodingBytesSizeMismatchError' },\n    )\n  }\n}\n\nexport type AbiEncodingLengthMismatchErrorType =\n  AbiEncodingLengthMismatchError & {\n    name: 'AbiEncodingLengthMismatchError'\n  }\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n      { name: 'AbiEncodingLengthMismatchError' },\n    )\n  }\n}\n\nexport type AbiErrorInputsNotFoundErrorType = AbiErrorInputsNotFoundError & {\n  name: 'AbiErrorInputsNotFoundError'\n}\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorInputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorNotFoundErrorType = AbiErrorNotFoundError & {\n  name: 'AbiErrorNotFoundError'\n}\nexport class AbiErrorNotFoundError extends BaseError {\n  constructor(\n    errorName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiErrorSignatureNotFoundErrorType =\n  AbiErrorSignatureNotFoundError & {\n    name: 'AbiErrorSignatureNotFoundError'\n  }\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiErrorSignatureNotFoundError',\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport type AbiEventSignatureEmptyTopicsErrorType =\n  AbiEventSignatureEmptyTopicsError & {\n    name: 'AbiEventSignatureEmptyTopicsError'\n  }\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n      name: 'AbiEventSignatureEmptyTopicsError',\n    })\n  }\n}\n\nexport type AbiEventSignatureNotFoundErrorType =\n  AbiEventSignatureNotFoundError & {\n    name: 'AbiEventSignatureNotFoundError'\n  }\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiEventNotFoundErrorType = AbiEventNotFoundError & {\n  name: 'AbiEventNotFoundError'\n}\nexport class AbiEventNotFoundError extends BaseError {\n  constructor(\n    eventName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiEventNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionNotFoundErrorType = AbiFunctionNotFoundError & {\n  name: 'AbiFunctionNotFoundError'\n}\nexport class AbiFunctionNotFoundError extends BaseError {\n  constructor(\n    functionName?: string | undefined,\n    { docsPath }: { docsPath?: string | undefined } = {},\n  ) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionOutputsNotFoundErrorType =\n  AbiFunctionOutputsNotFoundError & {\n    name: 'AbiFunctionOutputsNotFoundError'\n  }\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionOutputsNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiFunctionSignatureNotFoundErrorType =\n  AbiFunctionSignatureNotFoundError & {\n    name: 'AbiFunctionSignatureNotFoundError'\n  }\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n        name: 'AbiFunctionSignatureNotFoundError',\n      },\n    )\n  }\n}\n\nexport type AbiItemAmbiguityErrorType = AbiItemAmbiguityError & {\n  name: 'AbiItemAmbiguityError'\n}\nexport class AbiItemAmbiguityError extends BaseError {\n  constructor(\n    x: { abiItem: Abi[number]; type: string },\n    y: { abiItem: Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI items.', {\n      metaMessages: [\n        `\\`${x.type}\\` in \\`${formatAbiItem(x.abiItem)}\\`, and`,\n        `\\`${y.type}\\` in \\`${formatAbiItem(y.abiItem)}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n      name: 'AbiItemAmbiguityError',\n    })\n  }\n}\n\nexport type BytesSizeMismatchErrorType = BytesSizeMismatchError & {\n  name: 'BytesSizeMismatchError'\n}\nexport class BytesSizeMismatchError extends BaseError {\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\n      name: 'BytesSizeMismatchError',\n    })\n  }\n}\n\nexport type DecodeLogDataMismatchErrorType = DecodeLogDataMismatch & {\n  name: 'DecodeLogDataMismatch'\n}\nexport class DecodeLogDataMismatch extends BaseError {\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n        name: 'DecodeLogDataMismatch',\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport type DecodeLogTopicsMismatchErrorType = DecodeLogTopicsMismatch & {\n  name: 'DecodeLogTopicsMismatch'\n}\nexport class DecodeLogTopicsMismatch extends BaseError {\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n      { name: 'DecodeLogTopicsMismatch' },\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport type InvalidAbiEncodingTypeErrorType = InvalidAbiEncodingTypeError & {\n  name: 'InvalidAbiEncodingTypeError'\n}\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiEncodingType' },\n    )\n  }\n}\n\nexport type InvalidAbiDecodingTypeErrorType = InvalidAbiDecodingTypeError & {\n  name: 'InvalidAbiDecodingTypeError'\n}\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath, name: 'InvalidAbiDecodingType' },\n    )\n  }\n}\n\nexport type InvalidArrayErrorType = InvalidArrayError & {\n  name: 'InvalidArrayError'\n}\nexport class InvalidArrayError extends BaseError {\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'), {\n      name: 'InvalidArrayError',\n    })\n  }\n}\n\nexport type InvalidDefinitionTypeErrorType = InvalidDefinitionTypeError & {\n  name: 'InvalidDefinitionTypeError'\n}\nexport class InvalidDefinitionTypeError extends BaseError {\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n      { name: 'InvalidDefinitionTypeError' },\n    )\n  }\n}\n\nexport type UnsupportedPackedAbiTypeErrorType = UnsupportedPackedAbiType & {\n  name: 'UnsupportedPackedAbiType'\n}\nexport class UnsupportedPackedAbiType extends BaseError {\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`, {\n      name: 'UnsupportedPackedAbiType',\n    })\n  }\n}\n","import type { AbiParameter } from 'abitype'\n\nimport {\n  InvalidDefinitionTypeError,\n  type InvalidDefinitionTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { AbiItem } from '../../types/contract.js'\n\nexport type FormatAbiItemErrorType =\n  | FormatAbiParamsErrorType\n  | InvalidDefinitionTypeErrorType\n  | ErrorType\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`\n}\n\nexport type FormatAbiParamsErrorType = ErrorType\n\nexport function formatAbiParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName = false }: { includeName?: boolean | undefined } = {},\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => formatAbiParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nexport type FormatAbiParamErrorType = ErrorType\n\nfunction formatAbiParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${formatAbiParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","import type {\n  AbiParameter,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  type AbiEncodingArrayLengthMismatchErrorType,\n  AbiEncodingBytesSizeMismatchError,\n  type AbiEncodingBytesSizeMismatchErrorType,\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  InvalidAbiEncodingTypeError,\n  type InvalidAbiEncodingTypeErrorType,\n  InvalidArrayError,\n  type InvalidArrayErrorType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport { IntegerOutOfRangeError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type BoolToHexErrorType,\n  boolToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { integerRegex } from '../regex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\nexport type EncodeAbiParametersErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | PrepareParamsErrorType\n  | EncodeParamsErrorType\n  | ErrorType\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n *\n * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters\n *\n *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.\n *\n * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.\n * @param values - a set of values (values) that correspond to the given params.\n * @example\n * ```typescript\n * import { encodeAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' }\n *   ],\n *   ['wagmi', 420n, true]\n * )\n * ```\n *\n * You can also pass in Human Readable parameters with the parseAbiParameters utility.\n *\n * @example\n * ```typescript\n * import { encodeAbiParameters, parseAbiParameters } from 'viem'\n *\n * const encodedData = encodeAbiParameters(\n *   parseAbiParameters('string x, uint y, bool z'),\n *   ['wagmi', 420n, true]\n * )\n * ```\n */\nexport function encodeAbiParameters<\n  const params extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: params,\n  values: params extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<params>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values: values as any,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\ntype PrepareParamsErrorType = PrepareParamErrorType | ErrorType\n\nfunction prepareParams<const params extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: params\n  values: AbiParametersToPrimitiveTypes<params>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\ntype PrepareParamErrorType =\n  | EncodeAddressErrorType\n  | EncodeArrayErrorType\n  | EncodeBytesErrorType\n  | EncodeBoolErrorType\n  | EncodeNumberErrorType\n  | EncodeStringErrorType\n  | EncodeTupleErrorType\n  | GetArrayComponentsErrorType\n  | InvalidAbiEncodingTypeErrorType\n  | ErrorType\n\nfunction prepareParam<const param extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: param\n  value: AbiParameterToPrimitiveType<param>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(param.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeParamsErrorType = NumberToHexErrorType | SizeErrorType | ErrorType\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype EncodeAddressErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\ntype EncodeArrayErrorType =\n  | AbiEncodingArrayLengthMismatchErrorType\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  | InvalidArrayErrorType\n  | NumberToHexErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeArray<const param extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<param>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: param\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype EncodeBytesErrorType =\n  | AbiEncodingBytesSizeMismatchErrorType\n  | ConcatErrorType\n  | PadHexErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nfunction encodeBytes<const param extends AbiParameter>(\n  value: Hex,\n  { param }: { param: param },\n): PreparedParam {\n  const [, paramSize] = param.type.split('bytes')\n  const bytesSize = size(value)\n  if (!paramSize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = padHex(value_, {\n        dir: 'right',\n        size: Math.ceil((value.length - 2) / 2 / 32) * 32,\n      })\n    return {\n      dynamic: true,\n      encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_]),\n    }\n  }\n  if (bytesSize !== Number.parseInt(paramSize, 10))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: Number.parseInt(paramSize, 10),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\ntype EncodeBoolErrorType = PadHexErrorType | BoolToHexErrorType | ErrorType\n\nfunction encodeBool(value: boolean): PreparedParam {\n  if (typeof value !== 'boolean')\n    throw new BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\ntype EncodeNumberErrorType = NumberToHexErrorType | ErrorType\n\nfunction encodeNumber(\n  value: number,\n  { signed, size = 256 }: { signed: boolean; size?: number | undefined },\n): PreparedParam {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\ntype EncodeStringErrorType =\n  | ConcatErrorType\n  | NumberToHexErrorType\n  | PadHexErrorType\n  | SizeErrorType\n  | SliceErrorType\n  | StringToHexErrorType\n  | ErrorType\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\ntype EncodeTupleErrorType =\n  | ConcatErrorType\n  | EncodeParamsErrorType\n  // TODO: Add back once circular type reference is resolved\n  // | PrepareParamErrorType\n  | ErrorType\n\nfunction encodeTuple<\n  const param extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<param>,\n  { param }: { param: param },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\ntype GetArrayComponentsErrorType = ErrorType\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from './keccak256.js'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport type HashSignatureErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashSignature(sig: string) {\n  return hash(sig)\n}\n","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n","import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport type { Join } from '../types.js'\nimport {\n  type FormatAbiParameter,\n  formatAbiParameter,\n} from './formatAbiParameter.js'\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * type Result = FormatAbiParameters<[\n *   // ^? type Result = 'address from, uint256 tokenId'\n *   { type: 'address'; name: 'from'; },\n *   { type: 'uint256'; name: 'tokenId'; },\n * ]>\n */\nexport type FormatAbiParameters<\n  abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n> = Join<\n  {\n    [key in keyof abiParameters]: FormatAbiParameter<abiParameters[key]>\n  },\n  ', '\n>\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters<\n  const abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n>(abiParameters: abiParameters): FormatAbiParameters<abiParameters> {\n  let params = ''\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    params += formatAbiParameter(abiParameter)\n    if (i !== length - 1) params += ', '\n  }\n  return params as FormatAbiParameters<abiParameters>\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\ntype NormalizeSignatureParameters = string\ntype NormalizeSignatureReturnType = string\nexport type NormalizeSignatureErrorType = ErrorType\n\nexport function normalizeSignature(\n  signature: NormalizeSignatureParameters,\n): NormalizeSignatureReturnType {\n  let active = true\n  let current = ''\n  let level = 0\n  let result = ''\n  let valid = false\n\n  for (let i = 0; i < signature.length; i++) {\n    const char = signature[i]\n\n    // If the character is a separator, we want to reactivate.\n    if (['(', ')', ','].includes(char)) active = true\n\n    // If the character is a \"level\" token, we want to increment/decrement.\n    if (char === '(') level++\n    if (char === ')') level--\n\n    // If we aren't active, we don't want to mutate the result.\n    if (!active) continue\n\n    // If level === 0, we are at the definition level.\n    if (level === 0) {\n      if (char === ' ' && ['event', 'function', ''].includes(result))\n        result = ''\n      else {\n        result += char\n\n        // If we are at the end of the definition, we must be finished.\n        if (char === ')') {\n          valid = true\n          break\n        }\n      }\n\n      continue\n    }\n\n    // Ignore spaces\n    if (char === ' ') {\n      // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n      if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n        current = ''\n        active = false\n      }\n      continue\n    }\n\n    result += char\n    current += char\n  }\n\n  if (!valid) throw new BaseError('Unable to normalize signature.')\n\n  return result\n}\n","import type { AbiEvent, AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type HashSignatureErrorType, hashSignature } from './hashSignature.js'\nimport { type ToSignatureErrorType, toSignature } from './toSignature.js'\n\nexport type ToSignatureHashErrorType =\n  | HashSignatureErrorType\n  | ToSignatureErrorType\n  | ErrorType\n\n/**\n * Returns the hash (of the function/event signature) for a given event or function definition.\n */\nexport function toSignatureHash(fn: string | AbiFunction | AbiEvent) {\n  return hashSignature(toSignature(fn))\n}\n","import { type AbiEvent, type AbiFunction, formatAbiItem } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type NormalizeSignatureErrorType,\n  normalizeSignature,\n} from './normalizeSignature.js'\n\nexport type ToSignatureErrorType = NormalizeSignatureErrorType | ErrorType\n\n/**\n * Returns the signature for a given function or event definition.\n *\n * @example\n * const signature = toSignature('function ownerOf(uint256 tokenId)')\n * // 'ownerOf(uint256)'\n *\n * @example\n * const signature_3 = toSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // 'ownerOf(uint256)'\n */\nexport const toSignature = (def: string | AbiFunction | AbiEvent) => {\n  const def_ = (() => {\n    if (typeof def === 'string') return def\n    return formatAbiItem(def)\n  })()\n  return normalizeSignature(def_)\n}\n","import type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n  AbiStateMutability,\n} from '../abi.js'\nimport {\n  type FormatAbiParameters as FormatAbiParameters_,\n  formatAbiParameters,\n} from './formatAbiParameters.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport type FormatAbiItem<abiItem extends Abi[number]> =\n  Abi[number] extends abiItem\n    ? string\n    :\n        | (abiItem extends AbiFunction\n            ? AbiFunction extends abiItem\n              ? string\n              : `function ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends Exclude<\n                  AbiStateMutability,\n                  'nonpayable'\n                >\n                  ? ` ${abiItem['stateMutability']}`\n                  : ''}${abiItem['outputs']['length'] extends 0\n                  ? ''\n                  : ` returns (${FormatAbiParameters<abiItem['outputs']>})`}`\n            : never)\n        | (abiItem extends AbiEvent\n            ? AbiEvent extends abiItem\n              ? string\n              : `event ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiError\n            ? AbiError extends abiItem\n              ? string\n              : `error ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiConstructor\n            ? AbiConstructor extends abiItem\n              ? string\n              : `constructor(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiFallback\n            ? AbiFallback extends abiItem\n              ? string\n              : `fallback() external${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiReceive\n            ? AbiReceive extends abiItem\n              ? string\n              : 'receive() external payable'\n            : never)\n\ntype FormatAbiParameters<\n  abiParameters extends readonly (AbiParameter | AbiEventParameter)[],\n> = abiParameters['length'] extends 0\n  ? ''\n  : FormatAbiParameters_<\n      abiParameters extends readonly [\n        AbiParameter | AbiEventParameter,\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\n      ]\n        ? abiParameters\n        : never\n    >\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem<const abiItem extends Abi[number]>(\n  abiItem: abiItem,\n): FormatAbiItem<abiItem> {\n  type Result = FormatAbiItem<abiItem>\n  type Params = readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ]\n\n  if (abiItem.type === 'function')\n    return `function ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})${\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n        ? ` ${abiItem.stateMutability}`\n        : ''\n    }${\n      abiItem.outputs?.length\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\n        : ''\n    }`\n  if (abiItem.type === 'event')\n    return `event ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'error')\n    return `error ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'constructor')\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }`\n  if (abiItem.type === 'fallback')\n    return `fallback() external${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }` as Result\n  return 'receive() external payable' as Result\n}\n","import type { AbiFunction } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToFunctionSelectorErrorType =\n  | ToSignatureHashErrorType\n  | SliceErrorType\n  | ErrorType\n\n/**\n * Returns the function selector for a given function definition.\n *\n * @example\n * const selector = toFunctionSelector('function ownerOf(uint256 tokenId)')\n * // 0x6352211e\n */\nexport const toFunctionSelector = (fn: string | AbiFunction) =>\n  slice(toSignatureHash(fn), 0, 4)\n","import type { AbiError } from 'abitype'\n\n// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nexport const panicReasons = {\n  1: 'An `assert` condition failed.',\n  17: 'Arithmetic operation resulted in underflow or overflow.',\n  18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n  33: 'Attempted to convert to an invalid type.',\n  34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n  49: 'Performed `.pop()` on an empty array',\n  50: 'Array index is out of bounds.',\n  65: 'Allocated too much memory or created an array which is too large.',\n  81: 'Attempted to call a zero-initialized variable of internal function type.',\n} as const\n\nexport const solidityError: AbiError = {\n  inputs: [\n    {\n      name: 'message',\n      type: 'string',\n    },\n  ],\n  name: 'Error',\n  type: 'error',\n}\nexport const solidityPanic: AbiError = {\n  inputs: [\n    {\n      name: 'reason',\n      type: 'uint256',\n    },\n  ],\n  name: 'Panic',\n  type: 'error',\n}\n","import { InvalidBytesBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport {\n  type AssertSizeErrorType,\n  assertSize,\n  type HexToBigIntErrorType,\n  type HexToNumberErrorType,\n  hexToBigInt,\n  hexToNumber,\n} from './fromHex.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type FromBytesParameters<\n  to extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n> =\n  | to\n  | {\n      /** Size of the bytes. */\n      size?: number | undefined\n      /** Type to convert to. */\n      to: to\n    }\n\nexport type FromBytesReturnType<to> = to extends 'string'\n  ? string\n  : to extends 'hex'\n    ? Hex\n    : to extends 'bigint'\n      ? bigint\n      : to extends 'number'\n        ? number\n        : to extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromBytesErrorType =\n  | BytesToHexErrorType\n  | BytesToBigIntErrorType\n  | BytesToBoolErrorType\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes\n * - Example: https://viem.sh/docs/utilities/fromBytes#usage\n *\n * @param bytes Byte array to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(new Uint8Array([1, 164]), 'number')\n * // 420\n *\n * @example\n * import { fromBytes } from 'viem'\n * const data = fromBytes(\n *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),\n *   'string'\n * )\n * // 'Hello world'\n */\nexport function fromBytes<\n  to extends 'string' | 'hex' | 'bigint' | 'number' | 'boolean',\n>(\n  bytes: ByteArray,\n  toOrOpts: FromBytesParameters<to>,\n): FromBytesReturnType<to> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number')\n    return bytesToNumber(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'bigint')\n    return bytesToBigInt(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'boolean')\n    return bytesToBool(bytes, opts) as FromBytesReturnType<to>\n  if (to === 'string')\n    return bytesToString(bytes, opts) as FromBytesReturnType<to>\n  return bytesToHex(bytes, opts) as FromBytesReturnType<to>\n}\n\nexport type BytesToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean | undefined\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBigIntErrorType =\n  | BytesToHexErrorType\n  | HexToBigIntErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { bytesToBigInt } from 'viem'\n * const data = bytesToBigInt(new Uint8Array([1, 164]))\n * // 420n\n */\nexport function bytesToBigInt(\n  bytes: ByteArray,\n  opts: BytesToBigIntOpts = {},\n): bigint {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToBigInt(hex, opts)\n}\n\nexport type BytesToBoolOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToBoolErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { bytesToBool } from 'viem'\n * const data = bytesToBool(new Uint8Array([1]))\n * // true\n */\nexport function bytesToBool(\n  bytes_: ByteArray,\n  opts: BytesToBoolOpts = {},\n): boolean {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes)\n  }\n  if (bytes.length > 1 || bytes[0] > 1)\n    throw new InvalidBytesBooleanError(bytes)\n  return Boolean(bytes[0])\n}\n\nexport type BytesToNumberOpts = BytesToBigIntOpts\n\nexport type BytesToNumberErrorType =\n  | BytesToHexErrorType\n  | HexToNumberErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { bytesToNumber } from 'viem'\n * const data = bytesToNumber(new Uint8Array([1, 164]))\n * // 420\n */\nexport function bytesToNumber(\n  bytes: ByteArray,\n  opts: BytesToNumberOpts = {},\n): number {\n  if (typeof opts.size !== 'undefined') assertSize(bytes, { size: opts.size })\n  const hex = bytesToHex(bytes, opts)\n  return hexToNumber(hex, opts)\n}\n\nexport type BytesToStringOpts = {\n  /** Size of the bytes. */\n  size?: number | undefined\n}\n\nexport type BytesToStringErrorType =\n  | AssertSizeErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a byte array into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring\n *\n * @param bytes Byte array to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { bytesToString } from 'viem'\n * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // 'Hello world'\n */\nexport function bytesToString(\n  bytes_: ByteArray,\n  opts: BytesToStringOpts = {},\n): string {\n  let bytes = bytes_\n  if (typeof opts.size !== 'undefined') {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n","import type { AbiParameter } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { AbiItem } from '../../types/contract.js'\nimport { stringify } from '../stringify.js'\n\nexport type FormatAbiItemWithArgsErrorType = ErrorType\n\nexport function formatAbiItemWithArgs({\n  abiItem,\n  args,\n  includeFunctionName = true,\n  includeName = false,\n}: {\n  abiItem: AbiItem\n  args: readonly unknown[]\n  includeFunctionName?: boolean | undefined\n  includeName?: boolean | undefined\n}) {\n  if (!('name' in abiItem)) return\n  if (!('inputs' in abiItem)) return\n  if (!abiItem.inputs) return\n  return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs\n    .map(\n      (input: AbiParameter, i: number) =>\n        `${includeName && input.name ? `${input.name}: ` : ''}${\n          typeof args[i] === 'object' ? stringify(args[i]) : args[i]\n        }`,\n    )\n    .join(', ')})`\n}\n","import type { AbiParameter, AbiParametersToPrimitiveTypes } from 'abitype'\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n  type InvalidAbiDecodingTypeErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../address/getAddress.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceBytesErrorType, sliceBytes } from '../data/slice.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\nimport {\n  type BytesToBigIntErrorType,\n  type BytesToBoolErrorType,\n  type BytesToNumberErrorType,\n  type BytesToStringErrorType,\n  bytesToBigInt,\n  bytesToBool,\n  bytesToNumber,\n  bytesToString,\n} from '../encoding/fromBytes.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  params extends readonly AbiParameter[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  params extends readonly AbiParameter[] ? params : AbiParameter[]\n>\n\nexport type DecodeAbiParametersErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | DecodeParameterErrorType\n  | SizeErrorType\n  | CreateCursorErrorType\n  | ErrorType\n\nexport function decodeAbiParameters<\n  const params extends readonly AbiParameter[],\n>(\n  params: params,\n  data: ByteArray | Hex,\n): DecodeAbiParametersReturnType<params> {\n  const bytes = typeof data === 'string' ? hexToBytes(data) : data\n  const cursor = createCursor(bytes)\n\n  if (size(bytes) === 0 && params.length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data: typeof data === 'string' ? data : bytesToHex(data),\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n\n  let consumed = 0\n  const values = []\n  for (let i = 0; i < params.length; ++i) {\n    const param = params[i]\n    cursor.setPosition(consumed)\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: 0,\n    })\n    consumed += consumed_\n    values.push(data)\n  }\n  return values as DecodeAbiParametersReturnType<params>\n}\n\ntype DecodeParameterErrorType =\n  | DecodeArrayErrorType\n  | DecodeTupleErrorType\n  | DecodeAddressErrorType\n  | DecodeBoolErrorType\n  | DecodeBytesErrorType\n  | DecodeNumberErrorType\n  | DecodeStringErrorType\n  | InvalidAbiDecodingTypeErrorType\n\nfunction decodeParameter(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(cursor, { ...param, type }, { length, staticPosition })\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, { staticPosition })\n\n  if (param.type === 'address') return decodeAddress(cursor)\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n// Type Decoders\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\ntype DecodeAddressErrorType =\n  | ChecksumAddressErrorType\n  | BytesToHexErrorType\n  | SliceBytesErrorType\n  | ErrorType\n\nfunction decodeAddress(cursor: Cursor) {\n  const value = cursor.readBytes(32)\n  return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32]\n}\n\ntype DecodeArrayErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeArray(\n  cursor: Cursor,\n  param: AbiParameter,\n  { length, staticPosition }: { length: number | null; staticPosition: number },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = bytesToNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\ntype DecodeBoolErrorType = BytesToBoolErrorType | ErrorType\n\nfunction decodeBool(cursor: Cursor) {\n  return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32]\n}\n\ntype DecodeBytesErrorType =\n  | BytesToNumberErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nfunction decodeBytes(\n  cursor: Cursor,\n  param: AbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = bytesToNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = bytesToNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [bytesToHex(data), 32]\n  }\n\n  const value = bytesToHex(cursor.readBytes(Number.parseInt(size, 10), 32))\n  return [value, 32]\n}\n\ntype DecodeNumberErrorType =\n  | BytesToNumberErrorType\n  | BytesToBigIntErrorType\n  | ErrorType\n\nfunction decodeNumber(cursor: Cursor, param: AbiParameter) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256', 10)\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? bytesToBigInt(value, { signed })\n      : bytesToNumber(value, { signed }),\n    32,\n  ]\n}\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\ntype DecodeTupleErrorType = BytesToNumberErrorType | ErrorType\n\nfunction decodeTuple(\n  cursor: Cursor,\n  param: TupleAbiParameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = bytesToNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\ntype DecodeStringErrorType =\n  | BytesToNumberErrorType\n  | BytesToStringErrorType\n  | TrimErrorType\n  | ErrorType\n\nfunction decodeString(\n  cursor: Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = bytesToNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = bytesToNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = bytesToString(trim(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n","import type { Abi, ExtractAbiError } from 'abitype'\n\nimport { solidityError, solidityPanic } from '../../constants/solidity.js'\nimport {\n  AbiDecodingZeroDataError,\n  type AbiDecodingZeroDataErrorType,\n  AbiErrorSignatureNotFoundError,\n  type AbiErrorSignatureNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  ContractErrorArgs,\n  ContractErrorName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { slice } from '../data/slice.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeErrorResultParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n> = { abi?: abi | undefined; data: Hex }\n\nexport type DecodeErrorResultReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  ///\n  allErrorNames extends ContractErrorName<abi> = ContractErrorName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? UnionEvaluate<\n      {\n        [errorName in allErrorNames]: {\n          abiItem: abi extends Abi\n            ? Abi extends abi\n              ? AbiItem\n              : ExtractAbiError<abi, errorName>\n            : AbiItem\n          args: ContractErrorArgs<abi, errorName>\n          errorName: errorName\n        }\n      }[allErrorNames]\n    >\n  : {\n      abiItem: AbiItem\n      args: readonly unknown[] | undefined\n      errorName: string\n    }\n\nexport type DecodeErrorResultErrorType =\n  | AbiDecodingZeroDataErrorType\n  | AbiErrorSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport function decodeErrorResult<const abi extends Abi | readonly unknown[]>(\n  parameters: DecodeErrorResultParameters<abi>,\n): DecodeErrorResultReturnType<abi> {\n  const { abi, data } = parameters as DecodeErrorResultParameters\n\n  const signature = slice(data, 0, 4)\n  if (signature === '0x') throw new AbiDecodingZeroDataError()\n\n  const abi_ = [...(abi || []), solidityError, solidityPanic]\n  const abiItem = abi_.find(\n    (x) =>\n      x.type === 'error' && signature === toFunctionSelector(formatAbiItem(x)),\n  )\n  if (!abiItem)\n    throw new AbiErrorSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeErrorResult',\n    })\n  return {\n    abiItem,\n    args:\n      'inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0\n        ? decodeAbiParameters(abiItem.inputs, slice(data, 4))\n        : undefined,\n    errorName: (abiItem as { name: string }).name,\n  } as DecodeErrorResultReturnType<abi>\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,6,7,8,9,10,11,15,16,17]}